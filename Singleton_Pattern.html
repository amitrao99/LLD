<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Singleton Pattern Guide</title>
    <!-- Syntax Highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #34495e;
            --accent: #3498db;
            --bg: #f0f2f5;
            --card-bg: #ffffff;
            --text: #333;
            --border: #e0e0e0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            line-height: 1.6;
            color: var(--text);
            background-color: var(--bg);
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: var(--card-bg);
            padding: 50px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        }

        h1 {
            color: var(--primary);
            font-size: 2.5rem;
            border-bottom: 3px solid var(--accent);
            padding-bottom: 15px;
            margin-top: 0;
            margin-bottom: 30px;
        }

        h2 {
            color: var(--secondary);
            font-size: 1.8rem;
            margin-top: 40px;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 10px;
        }

        h3 {
            color: var(--secondary);
            font-size: 1.4rem;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        p {
            margin-bottom: 16px;
        }

        ul {
            margin-bottom: 16px;
            padding-left: 25px;
        }

        li {
            margin-bottom: 8px;
        }

        strong {
            color: var(--primary);
            font-weight: 700;
        }

        code {
            font-family: 'Fira Code', Consolas, Monaco, 'Andale Mono', monospace;
            background-color: #f4f4f4;
            padding: 2px 5px;
            border-radius: 4px;
            color: #e01e5a;
            font-size: 0.9em;
        }

        pre {
            border-radius: 8px;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            font-size: 0.95em;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            overflow: hidden;
        }

        table thead tr {
            background-color: var(--primary);
            color: #ffffff;
            text-align: left;
        }

        table th, table td {
            padding: 12px 15px;
        }

        table tbody tr {
            border-bottom: 1px solid #dddddd;
        }

        table tbody tr:nth-of-type(even) {
            background-color: #f9f9f9;
        }

        table tbody tr:last-of-type {
            border-bottom: 2px solid var(--primary);
        }

        hr {
            border: 0;
            height: 1px;
            background: #ddd;
            margin: 40px 0;
        }
        
        blockquote {
            border-left: 4px solid var(--accent);
            margin: 20px 0;
            padding: 10px 20px;
            background-color: #f9f9f9;
            color: #555;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">

<h2>1. What is the Singleton Pattern?</h2>
<p>The Singleton pattern is a <strong>design pattern that ensures a class has only ONE instance throughout the entire application</strong> and provides a global point of access to that instance.</p>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Only one instance of the class exists</li>
<li>The class controls its own instantiation</li>
<li>Provides a global access point to that instance</li>
</ul>
<h2>2. Use Cases - Why Do We Use It?</h2>
<p>Singleton is useful when:</p>
<p><strong>Configuration Management</strong> - You have app-wide settings that should be consistent everywhere. One config object for the whole app.</p>
<p><strong>Logging</strong> - You want one logger instance that writes to the same file/stream, avoiding conflicts.</p>
<p><strong>Database Connection Pools</strong> - Managing connections efficiently with a single pool manager.</p>
<p><strong>Caching</strong> - One centralized cache that all parts of your app can access.</p>
<p><strong>Thread Pools</strong> - Managing a shared pool of worker threads.</p>
<hr>
<hr>
<hr>
<hr>
<p>Perfect! Here are the <strong>different ways to implement Singleton in Java</strong>:</p>
<h2>1. <strong>Eager Initialization</strong></h2>
<pre><code class="language-java">
public class Singleton {

    // Instance created at class loading time

    private static final Singleton instance = new Singleton();

    

    private Singleton() {

        // Private constructor

    }

    

    public static Singleton getInstance() {

        return instance;

    }

}

</code></pre>
<p><strong>Pros:</strong> Simple, thread-safe (instance created at class loading)</p>
<p><strong>Cons:</strong> Instance created even if never used (wastes memory if not needed)</p>
<hr>
<h2>1. <strong>Eager Initialization - Why <code>final</code> and How Does Constructor Get Called?</strong></h2>
<h3>Why <code>final</code>?</h3>
<pre><code class="language-java">
private static final Singleton instance = new Singleton();

</code></pre>
<p>With <code>final</code>:</p>
<ul>
<li>The <strong>reference</strong> <code>instance</code> cannot be reassigned to point to a different object</li>
<li>The internals of the object CAN still change (if it has non-final fields)</li>
</ul>
<pre><code class="language-java">
// This is PREVENTED by final:

instance = new Singleton(); // ‚ùå Compilation error - can&#x27;t reassign



// But this is ALLOWED:

instance.setSomething(&quot;new value&quot;); // ‚úÖ OK - modifying object internals

</code></pre>
<p><strong>Why use it here?</strong> To guarantee that once the singleton instance is created, that reference never changes. Extra safety.</p>
<h3>Final Variables - Clarification</h3>
<p>You're right to be confused! Let me clarify:</p>
<pre><code class="language-java">
public class Example {

    private final int x;           // Must be initialized

    private final String name;     // Can be initialized later

    

    public Example() {

        // name = &quot;Test&quot;;  // ‚úÖ OK - initialized in constructor

        x = 10;            // ‚úÖ OK - initialized in constructor

    }

}

</code></pre>
<p><strong>For static final:</strong></p>
<pre><code class="language-java">
private static final Singleton instance = new Singleton(); // Must initialize here or in static block

</code></pre>
<h3><strong>Can Private Constructor Be Called During Class Loading?</strong></h3>
<p><strong>YES!</strong> The private constructor <strong>can be called from within the same class</strong>.</p>
<pre><code class="language-java">
public class Singleton {

    private static final Singleton instance = new Singleton(); // ‚úÖ This works!

    

    private Singleton() {

        System.out.println(&quot;Constructor called!&quot;);

    }

}

</code></pre>
<p><strong>What happens:</strong></p>
<p>1. JVM loads the <code>Singleton</code> class</p>
<p>2. Static initialization happens: <code>new Singleton()</code> is called</p>
<p>3. Even though constructor is private, it's being called <strong>from within the class itself</strong>, so it's allowed</p>
<p>4. The <code>instance</code> reference is set</p>
<p><strong>Private only means:</strong> "You can't call this from OUTSIDE the class"</p>
<hr>
<hr>
<hr>
<h2>2. <strong>Lazy Initialization</strong></h2>
<pre><code class="language-java">
public class Singleton {

    private static Singleton instance;

    

    private Singleton() {}

    

    public static Singleton getInstance() {

        if (instance == null) {

            instance = new Singleton();

        }

        return instance;

    }

}

</code></pre>
<p><strong>Pros:</strong> Instance created only when needed</p>
<p><strong>Cons:</strong> <strong>NOT thread-safe!</strong> Multiple threads can create multiple instances</p>
<hr>
<h2><strong>Lazy Initialization - How Is It NOT Thread-Safe?</strong></h2>
<p>Let me show you the <strong>exact race condition</strong>:</p>
<pre><code class="language-java">
public class Singleton {

    private static Singleton instance;  // null initially

    

    private Singleton() {

        System.out.println(&quot;Creating instance&quot;);

    }

    

    public static Singleton getInstance() {

        if (instance == null) {           // ‚Üê PROBLEM IS HERE

            instance = new Singleton();

        }

        return instance;

    }

}

</code></pre>
<h3><strong>The Race Condition:</strong></h3>
<pre><code class="language-java">
Time    Thread-1                          Thread-2

----    --------                          --------

T1      Check: instance == null? YES      

T2                                        Check: instance == null? YES

T3      Create new Singleton()            

T4                                        Create new Singleton()

T5      Return instance                   Return instance

</code></pre>
<p><strong>Both threads saw <code>null</code> and both created instances!</strong> You now have <strong>TWO singleton objects</strong> üí•</p>
<h3><strong>Real Example:</strong></h3>
<pre><code class="language-java">
// Simulating the race condition

public static void main(String[] args) {

    Thread t1 = new Thread(() -&gt; {

        Singleton s1 = Singleton.getInstance();

        System.out.println(&quot;Thread-1: &quot; + s1.hashCode());

    });

    

    Thread t2 = new Thread(() -&gt; {

        Singleton s2 = Singleton.getInstance();

        System.out.println(&quot;Thread-2: &quot; + s2.hashCode());

    });

    

    t1.start();

    t2.start();

}



// Possible Output:

// Creating instance

// Creating instance      ‚Üê TWO INSTANCES CREATED!

// Thread-1: 12345678

// Thread-2: 87654321     ‚Üê DIFFERENT hashCodes = different objects!

</code></pre>
<hr>
<hr>
<hr>
<h2>3. <strong>Thread-Safe Singleton (Synchronized Method)</strong></h2>
<pre><code class="language-java">
public class Singleton {

    private static Singleton instance;

    

    private Singleton() {}

    

    public static synchronized Singleton getInstance() {

        if (instance == null) {

            instance = new Singleton();

        }

        return instance;

    }

}

</code></pre>
<p><strong>Pros:</strong> Thread-safe</p>
<p><strong>Cons:</strong> <strong>Performance hit</strong> - synchronized on every call, even after instance is created</p>
<hr>
<hr>
<hr>
<h2>4. <strong>Double-Checked Locking</strong></h2>
<pre><code class="language-java">
public class Singleton {

    private static volatile Singleton instance;

    

    private Singleton() {}

    

    public static Singleton getInstance() {

        if (instance == null) {  // First check (no locking)

            synchronized (Singleton.class) {

                if (instance == null) {  // Second check (with locking)

                    instance = new Singleton();

                }

            }

        }

        return instance;

    }

}

</code></pre>
<p><strong>Pros:</strong> Thread-safe with better performance (synchronization only during creation)</p>
<p><strong>Cons:</strong> Complex, needs <code>volatile</code> keyword (pre-Java 5 had issues)</p>
<hr>
<h3><strong>Why Two Checks?</strong></h3>
<p><strong>First Check (outside synchronized):</strong></p>
<pre><code class="language-java">
if (instance == null) {  // Fast path - no locking overhead

</code></pre>
<ul>
<li><strong>99.99% of the time</strong>, instance is already created</li>
<li>This check avoids the expensive synchronized block</li>
<li><strong>Performance optimization</strong></li>
</ul>
<p><strong>Second Check (inside synchronized):</strong></p>
<pre><code class="language-java">
synchronized (Singleton.class) {

    if (instance == null) {  // Safety check

        instance = new Singleton();

    }

}

</code></pre>
<ul>
<li>Multiple threads might have passed the first check</li>
<li>Only one thread enters synchronized at a time</li>
<li>This thread needs to check AGAIN because another thread might have just created the instance</li>
</ul>
<h3><strong>Step-by-Step Example:</strong></h3>
<pre><code class="language-java">
Time    Thread-1                              Thread-2                              Thread-3

----    --------                              --------                              --------

T1      Check 1: instance == null? YES        

T2                                            Check 1: instance == null? YES        

T3                                                                                  Check 1: instance == null? YES

T4      Enter synchronized block              WAITING for lock                      WAITING for lock

T5      Check 2: instance == null? YES        

T6      Create instance                       

T7      Exit synchronized block               

T8                                            Enter synchronized block              

T9                                            Check 2: instance == null? NO ‚úÖ      WAITING

T10                                           Exit (no creation)                    

T11                                                                                 Enter synchronized

T12                                                                                 Check 2: instance == null? NO ‚úÖ

T13                                                                                 Exit (no creation)

</code></pre>
<p><strong>Without the second check:</strong></p>
<ul>
<li>Thread-2 would create ANOTHER instance</li>
<li>Thread-3 would create YET ANOTHER instance</li>
<li>Defeat the purpose of singleton!</li>
</ul>
<h3><strong>Why <code>volatile</code>?</strong></h3>
<pre><code class="language-java">
private static volatile Singleton instance;

</code></pre>
<p><strong>The problem without <code>volatile</code>:</strong></p>
<p>Creating an object is NOT atomic. It happens in 3 steps:</p>
<p>1. Allocate memory</p>
<p>2. Initialize the object</p>
<p>3. Assign reference to <code>instance</code></p>
<p><strong>Compiler might reorder</strong> steps 2 and 3:</p>
<p>1. Allocate memory</p>
<p>2. Assign reference to <code>instance</code> ‚Üê Now instance is NOT null but object NOT initialized!</p>
<p>3. Initialize the object</p>
<p><strong>Thread-1:</strong></p>
<pre><code class="language-java">
instance = new Singleton();  // Steps: 1 ‚Üí 3 ‚Üí 2 (reordered)

</code></pre>
<p><strong>Thread-2 (at the same time):</strong></p>
<pre><code class="language-java">
if (instance == null) {  // FALSE! (reference assigned)

    // skipped

}

return instance;  // üí• Returns UNINITIALIZED object!

</code></pre>
<p><strong><code>volatile</code> prevents this reordering</strong> and ensures proper visibility across threads.</p>
<hr>
<hr>
<hr>
<h2>5. <strong>Bill Pugh Singleton (Static Inner Helper Class)</strong> ‚≠ê</h2>
<pre><code class="language-java">
public class Singleton {

    

    private Singleton() {}

    

    // Inner static class - loaded only when getInstance() is called

    private static class SingletonHelper {

        private static final Singleton INSTANCE = new Singleton();

    }

    

    public static Singleton getInstance() {

        return SingletonHelper.INSTANCE;

    }

}

</code></pre>
<p><strong>Pros:</strong> Lazy loading + thread-safe + simple + no synchronization overhead</p>
<p><strong>Cons:</strong> None really!</p>
<hr>
<h3><strong>How It Works:</strong></h3>
<p><strong>Key Concept:</strong> Inner static classes are <strong>NOT loaded</strong> when the outer class is loaded. They're loaded <strong>only when referenced</strong>.</p>
<pre><code class="language-java">
public static void main(String[] args) {

    System.out.println(&quot;Main started&quot;);

    // Singleton class is loaded here, but SingletonHelper is NOT

    

    System.out.println(&quot;About to get instance&quot;);

    Singleton s = Singleton.getInstance();  // ‚Üê SingletonHelper loaded NOW!

    

    System.out.println(&quot;Got instance&quot;);

}



// Output:

// Main started

// About to get instance

// Singleton created          ‚Üê Created only when needed!

// Got instance

</code></pre>
<h3><strong>Why Is It Thread-Safe?</strong></h3>
<p><strong>JVM guarantees</strong> that class initialization is thread-safe. When <code>SingletonHelper</code> is loaded:</p>
<ul>
<li>Only ONE thread can initialize the class</li>
<li>Other threads wait</li>
<li>Static field initialization happens atomically</li>
</ul>
<pre><code class="language-java">
Thread-1 calls getInstance()

   ‚Üì

SingletonHelper needs to be loaded

   ‚Üì

JVM locks class initialization

   ‚Üì

Thread-2 calls getInstance() ‚Üí WAITS

Thread-3 calls getInstance() ‚Üí WAITS

   ‚Üì

INSTANCE created

   ‚Üì

SingletonHelper fully initialized

   ‚Üì

Lock released

   ‚Üì

All threads get the SAME instance

</code></pre>
<h3><strong>Benefits:</strong></h3>
<p>‚úÖ <strong>Lazy loading</strong> - Created only when needed</p>
<p>‚úÖ <strong>Thread-safe</strong> - JVM handles it</p>
<p>‚úÖ <strong>No synchronization overhead</strong> - No <code>synchronized</code> keyword</p>
<p>‚úÖ <strong>Simple and clean</strong> code</p>
<hr>
<hr>
<hr>
<h2>6. <strong>Enum Singleton</strong> ‚≠ê‚≠ê</h2>
<pre><code class="language-java">
public enum Singleton {

    INSTANCE;

    

    public void doSomething() {

        // Your methods here

    }

}



// Usage:

Singleton.INSTANCE.doSomething();

</code></pre>
<p><strong>Pros:</strong> Most secure, prevents reflection attacks, handles serialization automatically, guaranteed single instance by JVM</p>
<p><strong>Cons:</strong> Less flexible (can't extend classes, though you can implement interfaces)</p>
<hr>
<h3><strong>Example 1: Configuration Manager</strong></h3>
<pre><code class="language-java">
public enum ConfigManager {

    INSTANCE;

    

    private Properties properties;

    

    // Constructor runs once when enum is loaded

    ConfigManager() {

        properties = new Properties();

        properties.setProperty(&quot;app.name&quot;, &quot;MyApp&quot;);

        properties.setProperty(&quot;app.version&quot;, &quot;1.0&quot;);

        properties.setProperty(&quot;db.url&quot;, &quot;jdbc:mysql://localhost:3306/mydb&quot;);

    }

    

    public String getProperty(String key) {

        return properties.getProperty(key);

    }

    

    public void setProperty(String key, String value) {

        properties.setProperty(key, value);

    }

    

    public void loadFromFile(String filename) {

        try (FileInputStream fis = new FileInputStream(filename)) {

            properties.load(fis);

        } catch (IOException e) {

            e.printStackTrace();

        }

    }

}



// Usage:

public class App {

    public static void main(String[] args) {

        // Get configuration

        String appName = ConfigManager.INSTANCE.getProperty(&quot;app.name&quot;);

        System.out.println(&quot;App: &quot; + appName);

        

        // Update configuration

        ConfigManager.INSTANCE.setProperty(&quot;app.mode&quot;, &quot;production&quot;);

        

        // Load from file

        ConfigManager.INSTANCE.loadFromFile(&quot;config.properties&quot;);

    }

}

</code></pre>
<h3><strong>Example 2: Logger</strong></h3>
<pre><code class="language-java">
public enum Logger {

    INSTANCE;

    

    private PrintWriter writer;

    

    Logger() {

        try {

            writer = new PrintWriter(new FileWriter(&quot;app.log&quot;, true));

        } catch (IOException e) {

            e.printStackTrace();

        }

    }

    

    public void log(String message) {

        String timestamp = LocalDateTime.now().toString();

        writer.println(&quot;[&quot; + timestamp + &quot;] &quot; + message);

        writer.flush();

    }

    

    public void error(String message) {

        log(&quot;ERROR: &quot; + message);

    }

    

    public void info(String message) {

        log(&quot;INFO: &quot; + message);

    }

    

    public void close() {

        if (writer != null) {

            writer.close();

        }

    }

}



// Usage across your entire app:

public class UserService {

    public void createUser(String name) {

        Logger.INSTANCE.info(&quot;Creating user: &quot; + name);

        // ... create user logic

        Logger.INSTANCE.info(&quot;User created successfully&quot;);

    }

}



public class PaymentService {

    public void processPayment(double amount) {

        Logger.INSTANCE.info(&quot;Processing payment: $&quot; + amount);

        // ... payment logic

        Logger.INSTANCE.error(&quot;Payment failed!&quot;);

    }

}

</code></pre>
<h3><strong>Example 3: Database Connection Pool Manager</strong></h3>
<pre><code class="language-java">
public enum DatabaseManager {

    INSTANCE;

    

    private HikariDataSource dataSource;

    

    DatabaseManager() {

        HikariConfig config = new HikariConfig();

        config.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/mydb&quot;);

        config.setUsername(&quot;root&quot;);

        config.setPassword(&quot;password&quot;);

        config.setMaximumPoolSize(10);

        

        dataSource = new HikariDataSource(config);

    }

    

    public Connection getConnection() throws SQLException {

        return dataSource.getConnection();

    }

    

    public void executeQuery(String sql) {

        try (Connection conn = getConnection();

             Statement stmt = conn.createStatement();

             ResultSet rs = stmt.executeQuery(sql)) {

            

            while (rs.next()) {

                // Process results

            }

        } catch (SQLException e) {

            e.printStackTrace();

        }

    }

    

    public void shutdown() {

        if (dataSource != null) {

            dataSource.close();

        }

    }

}



// Usage:

public class UserDAO {

    public User findById(int id) {

        try (Connection conn = DatabaseManager.INSTANCE.getConnection()) {

            // ... query database

        } catch (SQLException e) {

            e.printStackTrace();

        }

        return null;

    }

}

</code></pre>
<h3><strong>Why Enum Is Powerful:</strong></h3>
<p>1. <strong>Serialization-safe</strong> - Even if serialized and deserialized, still ONE instance</p>
<p>2. <strong>Reflection-proof</strong> - Cannot create another instance via reflection</p>
<p>3. <strong>Thread-safe</strong> - JVM guarantees it</p>
<p>4. <strong>Concise</strong> - Shortest code</p>
<hr>
<hr>
<hr>
<h2>Quick Comparison</h2>
<table><thead><tr><th>Approach</th><th>Thread-Safe</th><th>Lazy Loading</th><th>Performance</th><th>Complexity</th></tr></thead><tbody><tr><td>Eager</td><td>‚úÖ</td><td>‚ùå</td><td>‚úÖ</td><td>Simple</td></tr><tr><td>Lazy</td><td>‚ùå</td><td>‚úÖ</td><td>‚úÖ</td><td>Simple</td></tr><tr><td>Synchronized</td><td>‚úÖ</td><td>‚úÖ</td><td>‚ùå</td><td>Simple</td></tr><tr><td>Double-Check</td><td>‚úÖ</td><td>‚úÖ</td><td>‚úÖ</td><td>Complex</td></tr><tr><td>Bill Pugh</td><td>‚úÖ</td><td>‚úÖ</td><td>‚úÖ</td><td>Simple</td></tr><tr><td>Enum</td><td>‚úÖ</td><td>‚ùå</td><td>‚úÖ</td><td>Simplest</td></tr></tbody></table>
<hr>
<hr>
<hr>
<h1>üéØ <strong>My Recommendation: Bill Pugh Singleton (Static Inner Helper Class)</strong></h1>
<p>This is the pattern you should <strong>master and use 90% of the time</strong>.</p>
<p><strong>Why?</strong></p>
<ul>
<li>‚úÖ Lazy loading (created only when needed)</li>
<li>‚úÖ Thread-safe (no synchronization needed)</li>
<li>‚úÖ High performance (no locking overhead)</li>
<li>‚úÖ Clean, simple code</li>
<li>‚úÖ Works perfectly for most real-world scenarios</li>
</ul>
<hr>
<h2><strong>Full-Fledged Real-World Implementation</strong></h2>
<p>Let me show you a complete <strong>Database Connection Manager</strong> - this is the kind of singleton you'll actually build in real projects.</p>
<h3><strong>The Singleton Class - DatabaseConnectionManager.java</strong></h3>
<pre><code class="language-java">
import java.sql.*;

import java.util.concurrent.BlockingQueue;

import java.util.concurrent.LinkedBlockingQueue;

import java.util.concurrent.atomic.AtomicInteger;

import java.util.Properties;

import java.io.FileInputStream;

import java.io.IOException;



public class DatabaseConnectionManager {

    

    // ========== SINGLETON PATTERN (Bill Pugh) ==========

    

    private DatabaseConnectionManager() {

        System.out.println(&quot;üîß Initializing DatabaseConnectionManager...&quot;);

        loadConfiguration();

        initializeConnectionPool();

        System.out.println(&quot;‚úÖ DatabaseConnectionManager initialized successfully!&quot;);

    }

    

    // Static inner class - loaded only when getInstance() is called

    private static class SingletonHelper {

        private static final DatabaseConnectionManager INSTANCE = new DatabaseConnectionManager();

    }

    

    public static DatabaseConnectionManager getInstance() {

        return SingletonHelper.INSTANCE;

    }

    

    // ========== INSTANCE VARIABLES (Singleton State) ==========

    

    private String dbUrl;

    private String dbUsername;

    private String dbPassword;

    private int maxPoolSize = 10;

    private int minPoolSize = 2;

    

    // Connection pool using thread-safe BlockingQueue

    private BlockingQueue&lt;Connection&gt; connectionPool;

    private BlockingQueue&lt;Connection&gt; usedConnections;

    

    // Statistics tracking (thread-safe atomic counters)

    private AtomicInteger totalConnectionsCreated = new AtomicInteger(0);

    private AtomicInteger activeConnections = new AtomicInteger(0);

    private AtomicInteger connectionRequestCount = new AtomicInteger(0);

    

    // ========== CONFIGURATION LOADING ==========

    

    private void loadConfiguration() {

        // In real app, load from config file

        // For demo, hardcoding values

        this.dbUrl = &quot;jdbc:mysql://localhost:3306/myapp_db&quot;;

        this.dbUsername = &quot;root&quot;;

        this.dbPassword = &quot;password123&quot;;

        this.maxPoolSize = 10;

        this.minPoolSize = 2;

        

        System.out.println(&quot;üìã Configuration loaded:&quot;);

        System.out.println(&quot;   DB URL: &quot; + dbUrl);

        System.out.println(&quot;   Max Pool Size: &quot; + maxPoolSize);

    }

    

    // Alternative: Load from properties file

    public void loadConfigurationFromFile(String configPath) {

        Properties props = new Properties();

        try (FileInputStream fis = new FileInputStream(configPath)) {

            props.load(fis);

            this.dbUrl = props.getProperty(&quot;db.url&quot;);

            this.dbUsername = props.getProperty(&quot;db.username&quot;);

            this.dbPassword = props.getProperty(&quot;db.password&quot;);

            this.maxPoolSize = Integer.parseInt(props.getProperty(&quot;db.pool.max&quot;, &quot;10&quot;));

            this.minPoolSize = Integer.parseInt(props.getProperty(&quot;db.pool.min&quot;, &quot;2&quot;));

            System.out.println(&quot;‚úÖ Configuration loaded from file: &quot; + configPath);

        } catch (IOException e) {

            System.err.println(&quot;‚ùå Error loading config file: &quot; + e.getMessage());

        }

    }

    

    // ========== CONNECTION POOL INITIALIZATION ==========

    

    private void initializeConnectionPool() {

        connectionPool = new LinkedBlockingQueue&lt;&gt;(maxPoolSize);

        usedConnections = new LinkedBlockingQueue&lt;&gt;(maxPoolSize);

        

        // Create initial connections (minimum pool size)

        for (int i = 0; i &lt; minPoolSize; i++) {

            try {

                Connection conn = createNewConnection();

                connectionPool.offer(conn);

                System.out.println(&quot;üîó Created initial connection &quot; + (i + 1) + &quot;/&quot; + minPoolSize);

            } catch (SQLException e) {

                System.err.println(&quot;‚ùå Error creating initial connection: &quot; + e.getMessage());

            }

        }

    }

    

    private Connection createNewConnection() throws SQLException {

        Connection conn = DriverManager.getConnection(dbUrl, dbUsername, dbPassword);

        totalConnectionsCreated.incrementAndGet();

        return conn;

    }

    

    // ========== GET CONNECTION (Main Method) ==========

    

    /**

     * Get a connection from the pool.

     * Thread-safe method.

     */

    public Connection getConnection() throws SQLException {

        connectionRequestCount.incrementAndGet();

        

        // Try to get from pool

        Connection conn = connectionPool.poll();

        

        // If pool is empty and we haven&#x27;t reached max, create new connection

        if (conn == null) {

            synchronized (this) {

                // Double-check after acquiring lock

                if (totalConnectionsCreated.get() &lt; maxPoolSize) {

                    conn = createNewConnection();

                    System.out.println(&quot;üÜï Created new connection (Total: &quot; + totalConnectionsCreated.get() + &quot;)&quot;);

                } else {

                    // Wait for available connection

                    System.out.println(&quot;‚è≥ Waiting for available connection...&quot;);

                    try {

                        conn = connectionPool.take(); // Blocks until available

                    } catch (InterruptedException e) {

                        Thread.currentThread().interrupt();

                        throw new SQLException(&quot;Interrupted while waiting for connection&quot;);

                    }

                }

            }

        }

        

        // Validate connection before returning

        if (conn != null &amp;&amp; !isConnectionValid(conn)) {

            System.out.println(&quot;üîÑ Connection invalid, creating new one&quot;);

            conn = createNewConnection();

        }

        

        usedConnections.offer(conn);

        activeConnections.incrementAndGet();

        

        return conn;

    }

    

    private boolean isConnectionValid(Connection conn) {

        try {

            return conn != null &amp;&amp; !conn.isClosed() &amp;&amp; conn.isValid(2);

        } catch (SQLException e) {

            return false;

        }

    }

    

    // ========== RELEASE CONNECTION ==========

    

    /**

     * Return a connection to the pool after use.

     * Thread-safe method.

     */

    public void releaseConnection(Connection conn) {

        if (conn != null) {

            usedConnections.remove(conn);

            connectionPool.offer(conn);

            activeConnections.decrementAndGet();

            System.out.println(&quot;‚úÖ Connection returned to pool&quot;);

        }

    }

    

    // ========== EXECUTE QUERY (Convenience Method) ==========

    

    /**

     * Execute a query and automatically manage connection lifecycle.

     */

    public void executeQuery(String sql, QueryCallback callback) {

        Connection conn = null;

        Statement stmt = null;

        ResultSet rs = null;

        

        try {

            conn = getConnection();

            stmt = conn.createStatement();

            rs = stmt.executeQuery(sql);

            

            // Execute callback with results

            callback.process(rs);

            

        } catch (SQLException e) {

            System.err.println(&quot;‚ùå Error executing query: &quot; + e.getMessage());

            e.printStackTrace();

        } finally {

            // Always clean up resources

            closeQuietly(rs);

            closeQuietly(stmt);

            if (conn != null) {

                releaseConnection(conn);

            }

        }

    }

    

    // Callback interface for query processing

    @FunctionalInterface

    public interface QueryCallback {

        void process(ResultSet rs) throws SQLException;

    }

    

    // ========== EXECUTE UPDATE (INSERT/UPDATE/DELETE) ==========

    

    public int executeUpdate(String sql) {

        Connection conn = null;

        Statement stmt = null;

        

        try {

            conn = getConnection();

            stmt = conn.createStatement();

            return stmt.executeUpdate(sql);

            

        } catch (SQLException e) {

            System.err.println(&quot;‚ùå Error executing update: &quot; + e.getMessage());

            return -1;

        } finally {

            closeQuietly(stmt);

            if (conn != null) {

                releaseConnection(conn);

            }

        }

    }

    

    // ========== STATISTICS &amp; MONITORING ==========

    

    public void printStatistics() {

        System.out.println(&quot;\nüìä ===== DATABASE CONNECTION POOL STATISTICS =====&quot;);

        System.out.println(&quot;Total Connections Created: &quot; + totalConnectionsCreated.get());

        System.out.println(&quot;Active Connections: &quot; + activeConnections.get());

        System.out.println(&quot;Available in Pool: &quot; + connectionPool.size());

        System.out.println(&quot;Connections in Use: &quot; + usedConnections.size());

        System.out.println(&quot;Total Connection Requests: &quot; + connectionRequestCount.get());

        System.out.println(&quot;Max Pool Size: &quot; + maxPoolSize);

        System.out.println(&quot;================================================\n&quot;);

    }

    

    public int getActiveConnectionCount() {

        return activeConnections.get();

    }

    

    public int getAvailableConnectionCount() {

        return connectionPool.size();

    }

    

    public int getTotalConnectionsCreated() {

        return totalConnectionsCreated.get();

    }

    

    // ========== SHUTDOWN &amp; CLEANUP ==========

    

    public void shutdown() {

        System.out.println(&quot;üõë Shutting down DatabaseConnectionManager...&quot;);

        

        // Close all connections in pool

        for (Connection conn : connectionPool) {

            closeQuietly(conn);

        }

        

        // Close all used connections

        for (Connection conn : usedConnections) {

            closeQuietly(conn);

        }

        

        connectionPool.clear();

        usedConnections.clear();

        

        System.out.println(&quot;‚úÖ DatabaseConnectionManager shut down successfully&quot;);

    }

    

    // ========== UTILITY METHODS ==========

    

    private void closeQuietly(AutoCloseable resource) {

        if (resource != null) {

            try {

                resource.close();

            } catch (Exception e) {

                // Ignore

            }

        }

    }

    

    // ========== CONFIGURATION GETTERS ==========

    

    public String getDbUrl() {

        return dbUrl;

    }

    

    public int getMaxPoolSize() {

        return maxPoolSize;

    }

    

    public int getMinPoolSize() {

        return minPoolSize;

    }

}

</code></pre>
<hr>
<h2><strong>Usage Scenarios - Multiple Services Using The Singleton</strong></h2>
<h3><strong>Scenario 1: UserService.java</strong></h3>
<pre><code class="language-java">
public class UserService {

    

    // No need to store instance - just call getInstance() when needed

    

    public void createUser(String username, String email) {

        DatabaseConnectionManager dbManager = DatabaseConnectionManager.getInstance();

        

        String sql = String.format(

            &quot;INSERT INTO users (username, email, created_at) VALUES (&#x27;%s&#x27;, &#x27;%s&#x27;, NOW())&quot;,

            username, email

        );

        

        int rowsAffected = dbManager.executeUpdate(sql);

        

        if (rowsAffected &gt; 0) {

            System.out.println(&quot;‚úÖ User created: &quot; + username);

        } else {

            System.out.println(&quot;‚ùå Failed to create user&quot;);

        }

    }

    

    public void findUserByEmail(String email) {

        DatabaseConnectionManager dbManager = DatabaseConnectionManager.getInstance();

        

        String sql = &quot;SELECT * FROM users WHERE email = &#x27;&quot; + email + &quot;&#x27;&quot;;

        

        dbManager.executeQuery(sql, rs -&gt; {

            if (rs.next()) {

                System.out.println(&quot;üë§ Found user:&quot;);

                System.out.println(&quot;   ID: &quot; + rs.getInt(&quot;id&quot;));

                System.out.println(&quot;   Username: &quot; + rs.getString(&quot;username&quot;));

                System.out.println(&quot;   Email: &quot; + rs.getString(&quot;email&quot;));

            } else {

                System.out.println(&quot;‚ùå User not found&quot;);

            }

        });

    }

    

    public void listAllUsers() {

        DatabaseConnectionManager dbManager = DatabaseConnectionManager.getInstance();

        

        dbManager.executeQuery(&quot;SELECT * FROM users&quot;, rs -&gt; {

            System.out.println(&quot;\nüìã All Users:&quot;);

            while (rs.next()) {

                System.out.printf(&quot;   %d | %s | %s%n&quot;,

                    rs.getInt(&quot;id&quot;),

                    rs.getString(&quot;username&quot;),

                    rs.getString(&quot;email&quot;)

                );

            }

        });

    }

}

</code></pre>
<h3><strong>Scenario 2: OrderService.java</strong></h3>
<pre><code class="language-java">
public class OrderService {

    

    public void createOrder(int userId, String productName, double amount) {

        DatabaseConnectionManager dbManager = DatabaseConnectionManager.getInstance();

        

        String sql = String.format(

            &quot;INSERT INTO orders (user_id, product_name, amount, order_date) &quot; +

            &quot;VALUES (%d, &#x27;%s&#x27;, %.2f, NOW())&quot;,

            userId, productName, amount

        );

        

        int result = dbManager.executeUpdate(sql);

        

        if (result &gt; 0) {

            System.out.println(&quot;üõí Order created: &quot; + productName + &quot; - $&quot; + amount);

        }

    }

    

    public void getOrdersByUser(int userId) {

        DatabaseConnectionManager dbManager = DatabaseConnectionManager.getInstance();

        

        String sql = &quot;SELECT * FROM orders WHERE user_id = &quot; + userId;

        

        dbManager.executeQuery(sql, rs -&gt; {

            System.out.println(&quot;\nüì¶ Orders for User &quot; + userId + &quot;:&quot;);

            double total = 0;

            while (rs.next()) {

                double amount = rs.getDouble(&quot;amount&quot;);

                total += amount;

                System.out.printf(&quot;   Order #%d: %s - $%.2f%n&quot;,

                    rs.getInt(&quot;id&quot;),

                    rs.getString(&quot;product_name&quot;),

                    amount

                );

            }

            System.out.printf(&quot;   Total: $%.2f%n&quot;, total);

        });

    }

}

</code></pre>
<h3><strong>Scenario 3: ProductService.java</strong></h3>
<pre><code class="language-java">
public class ProductService {

    

    public void addProduct(String name, double price, int stock) {

        DatabaseConnectionManager dbManager = DatabaseConnectionManager.getInstance();

        

        String sql = String.format(

            &quot;INSERT INTO products (name, price, stock) VALUES (&#x27;%s&#x27;, %.2f, %d)&quot;,

            name, price, stock

        );

        

        dbManager.executeUpdate(sql);

        System.out.println(&quot;üì¶ Product added: &quot; + name);

    }

    

    public void updateStock(String productName, int quantity) {

        DatabaseConnectionManager dbManager = DatabaseConnectionManager.getInstance();

        

        String sql = String.format(

            &quot;UPDATE products SET stock = stock + %d WHERE name = &#x27;%s&#x27;&quot;,

            quantity, productName

        );

        

        dbManager.executeUpdate(sql);

        System.out.println(&quot;üìà Stock updated for: &quot; + productName);

    }

}

</code></pre>
<hr>
<h2><strong>Complete Demo Application</strong></h2>
<pre><code class="language-java">
import java.util.concurrent.ExecutorService;

import java.util.concurrent.Executors;

import java.util.concurrent.TimeUnit;



public class SingletonDemo {

    

    public static void main(String[] args) throws InterruptedException {

        

        System.out.println(&quot;üöÄ Starting Singleton Demo Application\n&quot;);

        

        // ========== SCENARIO 1: Basic Usage ==========

        System.out.println(&quot;===== SCENARIO 1: Basic Single-Threaded Usage =====\n&quot;);

        

        UserService userService = new UserService();

        userService.createUser(&quot;john_doe&quot;, &quot;john@example.com&quot;);

        userService.createUser(&quot;jane_smith&quot;, &quot;jane@example.com&quot;);

        userService.findUserByEmail(&quot;john@example.com&quot;);

        

        OrderService orderService = new OrderService();

        orderService.createOrder(1, &quot;Laptop&quot;, 999.99);

        orderService.createOrder(1, &quot;Mouse&quot;, 25.50);

        orderService.getOrdersByUser(1);

        

        // Print statistics

        DatabaseConnectionManager.getInstance().printStatistics();

        

        // ========== SCENARIO 2: Verify Singleton Behavior ==========

        System.out.println(&quot;\n===== SCENARIO 2: Verify Singleton (Same Instance) =====\n&quot;);

        

        DatabaseConnectionManager instance1 = DatabaseConnectionManager.getInstance();

        DatabaseConnectionManager instance2 = DatabaseConnectionManager.getInstance();

        DatabaseConnectionManager instance3 = DatabaseConnectionManager.getInstance();

        

        System.out.println(&quot;Instance 1 hashCode: &quot; + instance1.hashCode());

        System.out.println(&quot;Instance 2 hashCode: &quot; + instance2.hashCode());

        System.out.println(&quot;Instance 3 hashCode: &quot; + instance3.hashCode());

        System.out.println(&quot;Are they same instance? &quot; + (instance1 == instance2 &amp;&amp; instance2 == instance3));

        

        // ========== SCENARIO 3: Multi-threaded Access ==========

        System.out.println(&quot;\n===== SCENARIO 3: Multi-threaded Access (Thread Safety) =====\n&quot;);

        

        ExecutorService executor = Executors.newFixedThreadPool(5);

        

        // Simulate 10 concurrent database operations

        for (int i = 0; i &lt; 10; i++) {

            final int taskId = i;

            executor.submit(() -&gt; {

                String threadName = Thread.currentThread().getName();

                System.out.println(&quot;üßµ &quot; + threadName + &quot; - Task &quot; + taskId + &quot; starting&quot;);

                

                // Each thread uses the SAME singleton instance

                DatabaseConnectionManager dbManager = DatabaseConnectionManager.getInstance();

                System.out.println(&quot;üßµ &quot; + threadName + &quot; - Got instance: &quot; + dbManager.hashCode());

                

                // Simulate database work

                try {

                    if (taskId % 2 == 0) {

                        userService.createUser(&quot;user_&quot; + taskId, &quot;user&quot; + taskId + &quot;@example.com&quot;);

                    } else {

                        orderService.createOrder(1, &quot;Product_&quot; + taskId, Math.random() * 100);

                    }

                    Thread.sleep((long)(Math.random() * 1000)); // Simulate work

                } catch (InterruptedException e) {

                    Thread.currentThread().interrupt();

                }

                

                System.out.println(&quot;üßµ &quot; + threadName + &quot; - Task &quot; + taskId + &quot; completed&quot;);

            });

        }

        

        // Shutdown executor and wait for completion

        executor.shutdown();

        executor.awaitTermination(30, TimeUnit.SECONDS);

        

        // Print final statistics

        System.out.println(&quot;\n===== FINAL STATISTICS =====&quot;);

        DatabaseConnectionManager.getInstance().printStatistics();

        

        // ========== SCENARIO 4: Direct Connection Management ==========

        System.out.println(&quot;\n===== SCENARIO 4: Manual Connection Management =====\n&quot;);

        

        try {

            java.sql.Connection conn = DatabaseConnectionManager.getInstance().getConnection();

            System.out.println(&quot;‚úÖ Got connection: &quot; + conn);

            

            // Use connection...

            System.out.println(&quot;üíº Doing some database work...&quot;);

            Thread.sleep(1000);

            

            // Always release!

            DatabaseConnectionManager.getInstance().releaseConnection(conn);

            System.out.println(&quot;‚úÖ Connection released&quot;);

            

        } catch (Exception e) {

            e.printStackTrace();

        }

        

        // ========== CLEANUP ==========

        System.out.println(&quot;\n===== CLEANUP =====&quot;);

        DatabaseConnectionManager.getInstance().shutdown();

        

        System.out.println(&quot;\n‚úÖ Demo completed successfully!&quot;);

    }

}

</code></pre>
<hr>
<h2><strong>Output Example:</strong></h2>
<pre><code class="language-java">
üöÄ Starting Singleton Demo Application



===== SCENARIO 1: Basic Single-Threaded Usage =====



üîß Initializing DatabaseConnectionManager...

üìã Configuration loaded:

   DB URL: jdbc:mysql://localhost:3306/myapp_db

   Max Pool Size: 10

üîó Created initial connection 1/2

üîó Created initial connection 2/2

‚úÖ DatabaseConnectionManager initialized successfully!

‚úÖ User created: john_doe

‚úÖ User created: jane_smith

üë§ Found user:

   ID: 1

   Username: john_doe

   Email: john@example.com

üõí Order created: Laptop - $999.99

üõí Order created: Mouse - $25.50



üìä ===== DATABASE CONNECTION POOL STATISTICS =====

Total Connections Created: 2

Active Connections: 0

Available in Pool: 2

Connections in Use: 0

Total Connection Requests: 5

Max Pool Size: 10

================================================



===== SCENARIO 2: Verify Singleton (Same Instance) =====



Instance 1 hashCode: 123456789

Instance 2 hashCode: 123456789

Instance 3 hashCode: 123456789

Are they same instance? true



===== SCENARIO 3: Multi-threaded Access (Thread Safety) =====



üßµ pool-1-thread-1 - Task 0 starting

üßµ pool-1-thread-1 - Got instance: 123456789

üßµ pool-1-thread-2 - Task 1 starting

üßµ pool-1-thread-2 - Got instance: 123456789

üßµ pool-1-thread-3 - Task 2 starting

üßµ pool-1-thread-3 - Got instance: 123456789

... (all threads use SAME instance)



===== FINAL STATISTICS =====



üìä ===== DATABASE CONNECTION POOL STATISTICS =====

Total Connections Created: 5

Active Connections: 0

Available in Pool: 5

Connections in Use: 0

Total Connection Requests: 27

Max Pool Size: 10

================================================



‚úÖ Demo completed successfully!

</code></pre>
<hr>
<h2><strong>Key Takeaways - Master These Points:</strong></h2>
<h3><strong>1. The Pattern Structure (Memorize This)</strong></h3>
<pre><code class="language-java">
public class MySingleton {

    private MySingleton() { /* private constructor */ }

    

    private static class Helper {

        private static final MySingleton INSTANCE = new MySingleton();

    }

    

    public static MySingleton getInstance() {

        return Helper.INSTANCE;

    }

}

</code></pre>
<h3><strong>2. When to Use</strong></h3>
<ul>
<li>‚úÖ Configuration managers</li>
<li>‚úÖ Database connection pools</li>
<li>‚úÖ Loggers</li>
<li>‚úÖ Cache managers</li>
<li>‚úÖ Thread pools</li>
<li>‚úÖ Any shared resource that should exist only once</li>
</ul>
<h3><strong>3. Thread Safety Is Automatic</strong></h3>
<ul>
<li>JVM guarantees inner class initialization is thread-safe</li>
<li>No need for <code>synchronized</code> keyword</li>
<li>No performance overhead</li>
</ul>
<h3><strong>4. Instance Variables Are Shared</strong></h3>
<ul>
<li>All parts of your app access THE SAME object</li>
<li>State is shared across all threads</li>
<li>Be careful with mutable state (use thread-safe collections)</li>
</ul>
<h3><strong>5. Lazy Loading Benefit</strong></h3>
<ul>
<li>Singleton created only when <code>getInstance()</code> is first called</li>
<li>Not created if never used</li>
<li>Saves memory and initialization time</li>
</ul>
<hr>
<p><strong>This is your go-to pattern. Practice it, understand it deeply, and you'll be set for 90% of singleton use cases!</strong> üéØ</p>
<p>‚úÖ <strong>Simple to understand</strong></p>
<p>‚úÖ <strong>Hard to get wrong</strong></p>
<p>‚úÖ <strong>No synchronization keywords to worry about</strong></p>
<p>‚úÖ <strong>No volatile keyword needed</strong></p>
<p><strong>Double-Checked Locking:</strong></p>
<p>‚ùå <strong>Requires understanding of synchronization</strong></p>
<p>‚ùå <strong>Requires understanding of volatile and memory visibility</strong></p>
<p>‚ùå <strong>Easy to forget <code>volatile</code> keyword (CRITICAL bug)</strong></p>
<p>‚ùå <strong>More complex logic flow</strong></p>
<h3><strong>2. The Volatile Keyword Problem</strong></h3>
<p><strong>This is the BIGGEST issue with Double-Checked Locking:</strong></p>
<pre><code class="language-java">
private static Singleton instance;  // ‚ùå WRONG! Missing volatile

</code></pre>
<p><strong>Without <code>volatile</code>, you get broken code that <em>seems</em> to work:</strong></p>
<h3><strong>3. Historical Issues (Before Java 5)</strong></h3>
<p><strong>Double-Checked Locking was actually BROKEN before Java 5 (2004):</strong></p>
<ul>
<li>Even with <code>volatile</code>, it didn't work correctly</li>
<li>Java Memory Model wasn't strong enough</li>
<li>Led to subtle, hard-to-debug bugs</li>
</ul>
<p><strong>Bill Pugh has ALWAYS worked correctly</strong> since it relies on class initialization guarantees that have always been in Java.</p>
<p><strong>Double-Checked Locking - Common Mistakes:</strong></p>
<p><strong>Mistake 1: Forgetting <code>volatile</code></strong></p>
<pre><code class="language-java">
private static Singleton instance;  // ‚ùå BUG! Needs volatile

</code></pre>
<p><strong>Mistake 2: Wrong synchronization</strong></p>
<pre><code class="language-java">
public static Singleton getInstance() {

    if (instance == null) {

        synchronized (instance) {  // ‚ùå WRONG! instance is null!

            // ...

        }

    }

}

</code></pre>
<p><strong>Mistake 3: Only one check</strong></p>
<pre><code class="language-java">
public static Singleton getInstance() {

    synchronized (Singleton.class) {

        if (instance == null) {  // ‚ùå Missing outer check - slower

            instance = new Singleton();

        }

    }

}

</code></pre>
<p><strong>Mistake 4: Synchronizing getInstance</strong></p>
<pre><code class="language-java">
public static synchronized Singleton getInstance() {  // ‚ùå Too slow

    if (instance == null) {

        instance = new Singleton();

    }

    return instance;

}

</code></pre>
<hr>
<h3><strong>6. Interview Perspective</strong></h3>
<p><strong>If interviewer asks: "Why Bill Pugh over DCL?"</strong></p>
<p><strong>Your answer should be:</strong></p>
<p>"Both patterns are thread-safe and performant. However, I prefer Bill Pugh because:</p>
<p>1. <strong>Simpler code</strong> - Easier to understand and maintain</p>
<p>2. <strong>Harder to mess up</strong> - No need to remember <code>volatile</code> keyword</p>
<p>3. <strong>No historical baggage</strong> - DCL was broken before Java 5</p>
<p>4. <strong>JVM handles thread safety</strong> - Relies on guaranteed class initialization</p>
<p>5. <strong>Same performance</strong> - Both are essentially field access after initialization</p>
<p>That said, Double-Checked Locking is also a valid choice post-Java 5 if you remember the <code>volatile</code> keyword. It's more explicit about lazy initialization."</p>
<hr>
<h3><strong>7. When You MIGHT Prefer Double-Checked Locking</strong></h3>
<p><strong>DCL can be better if:</strong></p>
<pre><code class="language-java">
public class Singleton {

    private static volatile Singleton instance;

    private ExpensiveResource resource;  // Expensive to create

    

    private Singleton() {

        // No initialization here

    }

    

    public static Singleton getInstance() {

        if (instance == null) {

            synchronized (Singleton.class) {

                if (instance == null) {

                    instance = new Singleton();

                }

            }

        }

        return instance;

    }

    

    // Initialize expensive resource ONLY when needed

    public void initializeResource() {

        if (resource == null) {

            synchronized (this) {

                if (resource == null) {

                    resource = new ExpensiveResource();  // Created on demand

                }

            }

        }

    }

}

</code></pre>
<p><strong>Use DCL when:</strong></p>
<ul>
<li>You want <strong>ultra-fine-grained</strong> control over initialization</li>
<li>You have <strong>multiple lazy-initialization points</strong> within the singleton</li>
<li>You're comfortable with the complexity</li>
</ul>
<hr>
<h2><strong>Cheat Sheet for Interviews</strong></h2>
<p><strong>Question:</strong> "Why not use Double-Checked Locking?"</p>
<p><strong>Answer:</strong></p>
<p>"DCL is a valid pattern, but I prefer Bill Pugh because:</p>
<ul>
<li>Simpler and cleaner code</li>
<li>No need to remember <code>volatile</code> (common mistake)</li>
<li>Relies on JVM guarantees (safer)</li>
<li>Same performance</li>
<li>No historical issues (DCL was broken pre-Java 5)</li>
</ul>
<p>Both are thread-safe and performant, but Bill Pugh is more maintainable."</p>
<p><strong>Question:</strong> "But DCL gives you more control!"</p>
<p><strong>Answer:</strong></p>
<p>"That's true if you need ultra-fine-grained lazy initialization. But in 95% of cases, Bill Pugh's simplicity outweighs that benefit. If I specifically needed deferred initialization of multiple resources, I might consider DCL or other lazy patterns."</p>
<hr>

    </div>
    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
</body>
</html>
